初学数据结构和算法

一、什么是数据结构？

数据存储在计算机内存中，决定了数据顺序和位置关系的便是“数据结构”。

（1）链表

链表中的数据呈线性排列。在链表中，数据的添加和删除都较为方便，就是访问比较耗费时间。
它们的特点是如何将数据与“指标”配对，以及指示下一条数据的内存位置。
在列表中，数据存储在内存中分散的位置。由于数据存储在不同位置，每个数据只能通过前面的指标访问。
数据的添加只需替换添加任一侧的指针即可执行。

![959EC25E54AE7BA25DAFA658D7340F16](https://github.com/user-attachments/assets/f921835e-c3aa-4664-8f84-73a4ff8ebd47)
![D9F8A1B254F1C9AC3E1C3B2652653A51](https://github.com/user-attachments/assets/2d9a6f45-19cf-4cf6-be02-8bfa47e75cca)
（2）数组

也是数据呈线性排列的一种数据结构。与链表不同，访问数据十分简单（随机访问），而添加和删除数据比较耗功夫。
每个元素可以通过索引进行访问（如a[0]、a[1]）。数据按顺序储存在连续位置的存储器中（由于储存在连续的位置，因此可以使用索引来计算内存地址，以便随机访问数据）。

（3）栈（LIFO，后进先出）

数据呈线性排列。但是只能访问最新添加的数据。
往栈中添加数据的操作叫做“入栈”（push）;从栈中取出数据的操作叫做“出栈”（pop）。

（4）队列（FIFO，先进先出）

数据呈线性排列。队列中添加和删除数据的操作分别是在两端进行的。可以类比排队。

（5）哈希表

擅长以“keys”和“values”组成的集合存储数据。
“哈希函数”是一个将数据转换为固定长度值的函数。下图为一个哈希表的示意图（采用了“链式方法”：当哈希值重叠时，使用链表，从而可以灵活处理不确定数量的数据），以姓名作为“keys”，以性别作为“values”。
![252F5B2A08666841D41602DFFD9463C5](https://github.com/user-attachments/assets/b45853ea-b055-4c5c-87c4-ff4a502df5d6)
如想要查找Dan的性别。
![F76C605C172B597C03B61DB1679C6B3A](https://github.com/user-attachments/assets/846279cb-e0e8-49df-99ec-7a552e00a583)
如果用于哈希表的数组太小，线性搜索更可能发生。相反，数组太大，许多数据盒子没有存储数据，浪费内存，要谨慎。

（6）堆

是一种图的树形结构，被用于实现“优先队列”（priority queues）。优先队列是一种数据结构，可以自由添加数据，但取出时要从最小值（或最大值）开始按顺序取出。
在堆的树形结构中，各个顶点被称为“结点”（node），数据就储存在这些结点中。
堆中的每一个结点最多有两个子结点。结点的排列顺序为从上到下，从左到右。

以根结点存储最小数据为例。
存储数据必须遵循：子节点必定大于父节点。
往堆中添加数据，一般会把新数据放在最下面一行靠左的位置。当最下面一行没有多余空间时，就再往下另起一行，把数据加在这一行最左端。

1.添加新数据

按顺序存放->比较父结点大小->判断是否交换父子结点位置->重复直至不需交换

添加数的时间复杂度为O(logn)

2.取出数据

取出最上方的数据->将最后的数据移到顶端->判断子节点小于父节点->父节点与左右最小子节点交换->重复直至不需交换

取出最小值的时间复杂度为O(1)，重构数的时间复杂度为O(logn)

（7）二叉查找树

二叉查找树是一种数据结构，采用了图的树形结构，数据就储存在结点中。可以看作二分查找算法思想树形结构的体现。

两个性质：每个结点的值均大于其其左子树上的任意一个结点的值；每个结点的值均小于右子树上任意一个结点的值。

结论：最小结点从顶端开始，往其左下的末端寻找；反过来，最大结点从顶端开始，往其右下的末端寻找。

1.添加数据

从顶端比较，小于左移，大于右移，移到最后一层（没有结点，就添加一层）。

2.删除结点

①要删除的结点没有子结点，直接删除即可。

②要删除的结点只有一个子结点，先删除目标结点，再把子结点移到被删除结点的位置上即可。

③要删除的结点有两个子结点，先删除目标结点，然后在被删除结点的左子树中寻找最大结点（或右子树的最小结点），最后将最大结点移到被删除节点的的位置。如果移动的结点还有子节点，就递归执行前面的操作。

3.查找结点

由“左<结点<右”，从顶端结点开始往下找，小于该结点左移，大于右移。

注：如果树的形状较为均衡时间复杂度为O(logn)。但是，如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度变为O(n)。
