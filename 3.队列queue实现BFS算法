//跳跃机器人
/*题目描述
地上有一排格子，共 n 个位置。机器猫站在第一个格子上，需要取第 n 个格子里的东西。
机器猫当然不愿意自己跑过去，所以机器猫从口袋里掏出了一个机器人！这个机器人的行动遵循下面的规则：
初始时，机器人位于 1 号格子
若机器人目前在 x 格子，那么它可以跳跃到 x−1,x+1,2x 里的一个格子（不允许跳出界）
问机器人最少需要多少次跳跃，才能到达 n 号格子。

输入格式
仅一行，一个正整数，表示 n。
输出格式
仅一行，一个正整数，表示最少跳跃次数。
*/

#include<iostream>
#include<queue>
using namespace std;
struct place
{
    int x; int step;
};
int jump(const int& n, queue<place>& q);
int main()
{
    int n;
    cin >> n;
    place p = { 1,0 };
    queue<place>q;
    q.push(p);
    cout << jump(n, q);
    return 0;
}
int jump(const int& n, queue<place>&q)
{
    vector<bool>visited(n + 1, 0);
    visited[1] = 1;
    while (!q.empty())
    {
        place p1 = q.front();
        q.pop();
        if (p1.x == n)
        {
            return p1.step;
        }
        if (((p1.x) - 1) >= 0 && ((p1.x) - 1) <= n&&!visited[(p1.x) - 1])
        {
            visited[(p1.x) - 1] = 1;
            place p2 = { (p1.x) - 1,(p1.step) + 1 };
            q.push(p2);
        }
        if (((p1.x) + 1) >= 0 && ((p1.x) + 1) <= n&&!visited[(p1.x) + 1])
        {
            visited[(p1.x) + 1]=1;
            place p2 = { (p1.x) + 1,(p1.step) + 1 };
            q.push(p2);
        }
        if (((p1.x)*2) >= 0 && ((p1.x)*2) <= n&&!visited[(p1.x) * 2])
        {
            visited[(p1.x) * 2]=1;
            place p2 = { (p1.x)*2,(p1.step) + 1 };
            q.push(p2);
        }
    }
}
