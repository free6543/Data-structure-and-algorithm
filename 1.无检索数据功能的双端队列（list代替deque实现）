//双端队列（双向链表list实现）
/*题目描述
请你实现 m 个双端队列，支持如下的 q 次操作：
push_back(a,x)：在第 a 个双端队列中从尾部插入一个元素 x；
pop_back(a)：在第 a 个双端队列中从尾部弹出一个元素。
push_front(a,x)：在第 a 个双端队列中从头部插入一个元素 x；
pop_front(a)：在第 a 个双端队列中从头部弹出一个元素。
size(a)：查询第 a 个双端队列的元素个数；
front(a)：查询第 a 个双端队列的队首元素；
back(a)：查询第 a 个双端队列的队尾元素；
对于 pop_back，pop_front，front 和 back 操作，若当前双端队列为空则不进行，直接跳过该次操作。

输入格式
输入的第一行是一个正整数 q，表示操作次数。
接下来 q 行，每行先是一个字符串，保证为 push_back 或者 pop_back 或者 push_front 或者 pop_front 或者 size 或者 front 或者 back 之一。接下来是 1 或 2 个正整数，分别表示 a 和 x。
输出格式
对于每个 size 或者 front 或者 back 操作，输出一行表示答案。
*/

#include<iostream>
#include<list>
#include<string>
using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    list<int> arr[1000001]={};
    int q;
    cin>>q;
    for(int i=0;i<q;i++)
    {
        string s;cin>>s;
        if(s=="push_back")
        {
            int a,x;
            cin>>a>>x;
            arr[a].push_back(x);
        }
        else if(s=="pop_back")
        {
            int a;
            cin>>a;
            if(!arr[a].empty())
            {
                arr[a].pop_back();
            }
        }
        else if(s=="push_front")
        {
            int a,x;
            cin>>a>>x;
            arr[a].push_front(x);
        }
        else if(s=="pop_front")
        {
            int a;
            cin>>a;
            if(!arr[a].empty())
            {
                arr[a].pop_front();
            }
        }
        else if(s=="size")
        {
            int a;
            cin>>a;
            cout<<arr[a].size()<<"\n";
        }
        else if(s=="front")
        {
            int a;
            cin>>a;
            if(!arr[a].empty())
            {
                cout<<arr[a].front()<<"\n";
            }
        }
        else if(s=="back")
        {
            int a;
            cin>>a;
            if(!arr[a].empty())
            {
                 cout<<arr[a].back()<<"\n";
            }
        }
    }
    return 0;
}
