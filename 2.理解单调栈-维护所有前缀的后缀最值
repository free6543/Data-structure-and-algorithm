//求数列所有后缀最大值的位置
/*题目描述
给定一个数列 a，初始为空。有 n 次操作，每次在 a 的末尾添加一个正整数 x。
每次操作结束后，请你找到当前 a 所有的后缀最大值的下标（下标从 1 开始）。一个下标 i 是当前 a 的后缀最大值下标当且仅当：对于所有的 i<j≤∣a∣，都有 a i>a j​，其中 ∣a∣ 表示当前 a 的元素个数。

为了避免输出过大，请你每次操作结束后都输出一个整数，表示当前数列所有后缀最大值的下标的按位异或和。
输入格式
第一行是一个整数，表示操作次数 n。
第二行有 n 个整数，依次表示 n 次操作所添加的整数 x i。
输出格式
每次操作后请输出一行一个整数，表示当前数列所有后缀最大值下标的按位异或和。
*/

/*思路：
考虑用一个栈按顺序维护当前数列的所有后缀最大值的位置（下标）。初始时栈是空的。
注意到这个栈里下标对应的数列元素（而不是下标本身）是单调递减的。

插入 a x​后，会删掉原有后缀最大值下标中那些满足 a y ≤ a x的下标 y，其他位置不变。然后 x 成为新的后缀最大值下标。
考虑因为这个栈里下标对应的数列元素是单调的，所以要删掉那些不再是后缀最大值下标的 y，只需要不断地在这个栈顶部弹出元素（也就是把栈里元素自底向顶写成序列后，不断地从后面删除元素），直到栈为空
或栈顶元素 t 满足 a t > a x。最后将 x 入栈即可。
*/

#include<iostream>
#include<vector>
#include<stack>
using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    vector<unsigned long long>vec;
    stack<int>stk;
    unsigned long long ans=0;
    for(int i=0;i<n;i++)
    {
        unsigned long long x;
        cin>>x;
        vec.push_back(x);
        while((!stk.empty())&&(vec[stk.top()]<=vec[i]))
        {
            ans^=(stk.top()+1);
            stk.pop();
        }
        stk.push(i);
        ans^=(stk.top()+1);
        cout<<ans<<"\n";
    }
    return 0;
}
